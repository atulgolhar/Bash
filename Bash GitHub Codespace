#  notes for bash GitHub Codespaces (cloud based terminal to practice)

In GitHub, on your repository, Code, Codespaces, and GitHub lauches a dev environment. What is it? VS code in the browswer.
Theme: Light+
CTRL ~          # to open terminal in Git Codespaces
ls -l
code while_loop

help cd         # partial info, standalone line
cd --help       # partial info, used when in the middle of a line of code but need help (so dont need to delete the written code)
pwd --help
/EXAMPLE        # to search
man cd          # full info which opens a text file 

Azure:        cd --help       # also works for Azure

pwd
whoami
cd ~
cd /workspaces/bash-for-beginners
tree            # offers tree view with directories ~-1-2-3
cd 1/           # cd into 1
cd 2/3          # cd into 3
cd ../..        # to jump from 3 back into 2 back into 1
pushd 2/3       # cd into 3
popd

# to look at the stack 1/2/3
// 0  ~/1/2/3
// 1  ~/1

# sitting inside 3 but want to popd (pop directories)
~1/2/3  $ popd            # want to pop off last directory that was added, thus takes you to ~/1
~/1
        $ dirs -v
0 ~/1   $

ls -l
ls -a
ls S*           # greps all files with S
ls [CS]*        # greps any file or foler that begins with C or S 
ls *.md         # greps any file with a md extension
ls *.??         # returns two characters
ls *.???        # returns three characters
ls [[:upper:]]*         # greps any file with upper case characters followed any characters
touch Text1file.txt     # creates text file
ls [[:lower:]]*         # returns any file with lower case character


# whereis, which, find
whereis bash
whereis -b bash                 # returns binaries, source files, and 
which bash                      # returns executables
find . -name "*.md"             # retuns list of of all markdown files in current workspace using .
find /home -name file.txt       # find files with expressions or names
find /home -iname file.txt      # find files outside the current working directory that you are in
find . -type d                  # type directory
find . -type f                  # type files



// Video 8 of 20
# mkdir
mkdir project01 project02 project03 project04
mkdir project01 project 02 project03
mkdir -p projects01/sub1/sub2                   # --parent  will make the parent directory as needed

#touch
touch project01/file.txt

# mv
mv project01/file.txt project02
ls project02

# cp
cp project02/file.txt project01/file400.txt             # copy file to new folder and change file name
ls project01
cp project02/file.txt project01/                        # '/' not necessary

# cleanup now, use rm remove or rmdir
rm file*                                        # wildcard to remove all file*
rmdir sub1/                                     # need to remove the lowest path if use rmdir without any options
rmdir sub1*
rmdir project*                                  # removes all project directories as long as those directories are empty



// Video 9 of 20

# cat 
cat quotes01.txt                                # concatenate file contents
cat quotes01.txt quotes02.txt                   # returns all quotes from both files

# head
head fake001.log                                # returns first 10 lines by default
head -n 3 fake001.log                           # able to specify how many lines returned. Here returns first 3 lines
head -n 5 fake001.log                           # returns first 5 lines from log file
tail fake001.log                                # returns last 10 lines by default
tail -n 3 fake001.log                           # returns last 3 lines
more fake002.log                                # returns text from that file in a page by page format
less --help                                     # inline help function called. Uses summary of man page
                                                # to use, type / then items you are searching for

# grep                                          # can use Regular Expressions to further refine your search
grep --help
grep "174.212.2.233" fake002.log
grep "DELETE" fake002.log



// Video 10 of 20

# environment variables                         # must know b/c applications, command line tools and shell scripts use envir variables to determine configuration

env
env $SHELL                                      # location of the shell
env $HOME                                       # location of the directory of the current user
env $USER
env $PATH                                       # locations to executables
export --help                                   # to create a new env variable (ie to set export attributes for shell variables)
export newVar=value
env                                             # pulls up env then search for newVar

# how to persist environment variables across sessions?         # startup files
ls /etc/profile                                 # global configuration which is located under /etc/profile 
                                                # if make changes to this file then it affects every user logged into this machine 
                                                # or every user logged into the bash session
                                                
ls -a ~                                         # (1) look for the .profile which exists under the user's home directory
                                                # so here we ls -a the home directory of this VS code user, then we will see a .profile 
                                                # that was created by this codespace that has a number of options in there that is configuring this session.
                                                # (2) also look for the .bashrc file.
                                                # Each of (1) and (2) are loaded into the session when you start a new prompt or bash session,
                                                # so if you put the export command inside one of those files, it would be automatically loaded and shared 
                                                # and persisted across your different sessions.



# Video 11 of 20
# using redirection and pipelines in Bash       # redirection will overwrite vs append will only append and not overwrite
# you see on the screen is the Standard Output.

s -l
ls -l > output.txt                      # redirect std output to new file called output.txt (actually called output10.txt in my session).
cat output.txt
ls -l >> output.txt                     # append the text to the existing file (and not override the existing text)
                                        # thus single > is redirect
                                        #      double >> is append to existing file
                                        
# STREAM std output is one the stream presented to the terminal
# STREAM std error is another stream presented to the terminal

stdin - standard input or stdin device to give commands is the keyboard 
stdout - standard output or stdout device is your terminal screen
stderr - standard error "2"
redirection - you can change the standard input/output. 

# Output Redirection  ">"
$ ls -al > listings 
$ cat file.text > /exampleFolder1/exampleSubFolder1/file10.txt
$ cat music.mp3 > /dev/audio

# Input Redirection   "<"
“>” is the output redirection operator. “>>” appends output to an existing file
“<” is the input redirection operator
“>&” redirects output of one file to another

 & is needed to tell the shell you mean a file descriptor, not a file name.

The numbers are file descriptors and only the first three (starting with zero) have a standardized meaning:

File Descriptors = #
0 - stdin
1 - stdout
2 - stderr              # to redirect the stderr you must add the fd (File Descriptor) to the front of the Operator
So each of these numbers in your command refer to a file descriptor. 

You can either redirect a file descriptor to a file with >                      // so here need a file name
or 
redirect it to another file descriptor with >&                                  // so here need a file descriptor value

The 3>&1 in your command line will create a new file descriptor and 
redirect it to 1 which is STDOUT. 
Now 1>&2 will redirect the file descriptor 1 to STDERR 
and 2>&3 will redirect file descriptor 2 to 3 which is STDOUT.

>name means redirect output to file name
>&number means redirect output to file descriptor number
the & is needed to tell the shell you mean a file descriptor, not a file name
